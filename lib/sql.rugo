# gummy/sql â€” SQL helpers for safe quoting and condition building.
#
# Provides identifier validation, operator whitelisting, and
# value quoting to prevent SQL injection.

use "str"
use "conv"
use "re"

# Validate a SQL identifier (table name, column name).
# Only allows [a-zA-Z_][a-zA-Z0-9_]*.
def validate_ident(name, context)
  if !re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', name)
    raise("gummy: invalid " + context + ": " + name)
  end
  return name
end

# Validate a SQL operator.
Valid_ops = ["=", "!=", "<>", "<", ">", "<=", ">=", "LIKE", "NOT LIKE", "IS", "IS NOT"]

# Validate a SQL comparison operator.
# Only allows: =, !=, <>, <, >, <=, >=, LIKE, NOT LIKE, IS, IS NOT.
def validate_op(op)
  uop = str.upper(op)
  for valid in Valid_ops
    if uop == valid
      return op
    end
  end
  raise("gummy: invalid operator: " + op)
end

# Safely quote a value for SQL embedding.
def quote(val)
  if val == nil
    return "NULL"
  end
  t = type_of(val)
  if t == "Integer" || t == "Float"
    return conv.to_s(val)
  end
  if t == "Boolean"
    if val
      return "1"
    end
    return "0"
  end
  s = conv.to_s(val)
  s = str.replace(s, "'", "''")
  return "'" + s + "'"
end

# Escape a string for use inside SQL string literals (e.g. FTS5 function args).
def escape_string(val)
  return str.replace(val, "'", "''")
end

# Build a WHERE clause from a hash of conditions.
# Keys can include operators: {"age >=" => 18, name: "Alice"}
# Multiple conditions are AND'd.
def build_where(conditions)
  parts = []
  for key, val in conditions
    if str.contains(key, " ")
      tokens = str.split(key, " ")
      col = validate_ident(tokens[0], "column")
      op = validate_op(tokens[1])
      append parts, col + " " + op + " " + quote(val)
    else
      validate_ident(key, "column")
      append parts, key + " = " + quote(val)
    end
  end
  return str.join(parts, " AND ")
end

# Build a chainable SELECT query for a table.
# Each method returns the query hash, enabling fluid chaining.
#
#   sql.query("users").where(clause).order_by("name").limit(10).to_sql()
#
def query(table)
  validate_ident(table, "table")

  q = {
    __table__: table,
    __select__: "*",
    __conditions__: [],
    __order__: nil,
    __limit__: nil
  }

  q["select"] = fn(cols)
    q.__select__ = cols
    return q
  end

  q["where"] = fn(clause)
    q.__conditions__ = append(q.__conditions__, clause)
    return q
  end

  q["order_by"] = fn(field)
    q.__order__ = field
    return q
  end

  q["limit"] = fn(n)
    q.__limit__ = n
    return q
  end

  q["to_sql"] = fn()
    s = "SELECT " + q.__select__ + " FROM " + q.__table__
    if len(q.__conditions__) > 0
      s = s + " WHERE " + str.join(q.__conditions__, " AND ")
    end
    if q.__order__ != nil
      s = s + " ORDER BY " + q.__order__
    end
    if q.__limit__ != nil
      s = s + " LIMIT " + conv.to_s(q.__limit__)
    end
    return s
  end

  return q
end
